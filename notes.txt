for(int i=0; i < n/2; i++)
{
	...
}

T(n) = (n/2)*c = cn/2
O(n)

-----------------------------

for(int j = 1; j < n; j*=2)
{
	...
}

T(n) = log2(n)
O(log2(n))

-----------------------------

for (int j = 1; j < n; j*= 3)
{
	...
}

T(n) = log3(n)
O(log3(n))

-----------------------------

for(i = 0; i < n/2; i++)
{
    for (int j = 1; j < n; j*=2)
    {
        ...
    }
    ...
}

T(n) = o1 + o2
T(n) = (cn/2) + (cn/2 * log2(n))
O(nlog2(n))

-----------------------------

for (int i = n; i > 0; i/=3)
{
    ...
}

T(n) = log3(n)
O(log3(n))

-----------------------------

ADT
Abstract Data Type

Type:   boolean|Integer
Data Item:  One of a Type
Data type: Type + operation

Physical                Logical
-------------------------------
Contiguous                Index

Array:
Linked List:
Doubly Linked List:

	inserting	(end)	O(1)	(middle)	O(n)
	O(1)
	deleting			O(n)
	O(1)
	searching			O(n)
	O(u)
	sorting				O(n^2)
	O(bs)

-----------------------------
=============================
Linked Lists
everytime
	ClassName	variableName; //Null; sets aside empty reference; declaring

difference between declare and initialize

	variableName = new ClassName(); //initializing

Car c = new Car(); //declaring and initializing

Class Node
{
	private int data;
	private Node link;

	public Node()
	{
		this.data = 0;
		this.link = null;
	}

	public void setData(int x)
	{
		this.data = x
	}
	public int getData()
	{
	return this.data;
	}
	public void setLink(Node link)
	{
		this.link = link;
	}
	public Node getLink()
	{
		return this.link;
	}
}

Node head;
Node curr;
head = new Node();
head.setData(5);
curr = head;
curr.setLink(new Node());
curr = curr.getLink();
curr.setData(7);

curr.setLink(new Node());
//Node p = new Node();
//curr.setLink(p);
curr.getLink().setData(15);
curr.setData(9);
curr.getLink().getLink() = new Node();

curr.getLink().getLink().setData(10);

curr = curr.getLink().getLink();

Node n = head;
wile(n != null)
{
	System.out.print(n.getData() + " ");
	n = n.getLink();
}
System.out.println();
==============================================================================
Node n = new Node();
n.setData(7);
n.setLink(curr.getLink());
curr.setLink(n);

[head]--[2| ]--[3| ]--[6| ]--[9| ]
[curr]
[p]--[8| ]
[g]

Node p,g;
p = new Node();
p.setData(8);
g = new Node;
//need to finish
==============================================================================
Node head,tail,curr;

head = tail = null;
curr = new Node();
curr.setData(42);
if(head == null);
{
	head = tail = curr;
}
else
{
	tail.setLink(curr);
	tail = curr;
}

Node head,curr;

head = null;
curr = new Node();
curr.setData(42);
curr.setLink(head);
head = curr;
==============================================================================

Doubly Linked List

Class Node
{
	private int data;
	private Node next;
	private Node prev;
	//===
}

Circular Linked List

Class Node
{

}
==============================================================================
Stacks

push peek
pop  size
     isEmpty()
     isFull()
LIFO
FILO

Queue

FIFO dequeue
     O(1)
LILO enqueue
     O(1)

==============================================================================
affixes

infx
postfix
prefix

9+3
93+
+93
------------------------------------------------------------------------------
a+b*c
abc*+

a*b+c
ab*c+

a*b+c*d
ab*cd*+

a+b*c+d
abc*+d+

(d+c)*a+b
dc+a*b+

c/(a+(b-d))*e*f
cabd-+/e*f*

3*4*(5+6-8)/((7-3)*4-2)
34*56+8-*73-4*2-/

1*7/(4*5+7)*(8^4)-2^3^5
17*45*7+/84^*235^^-
------------------------------------------------------------------------------
stack for evaluating postfix
	if(operand)
	{
		push()
	}
	if(operator)
	{
		pop()
		pop()
		evaluate
		push(result)
	}
------------------------------------------------------------------------------
529*- = 23
75+9*6+ = 114
75-9/6- = -6 //integer division
12/5*6- = -6

token	|Rank(infix)|Rank(postfix)
	(	|	4		|	-
	^	|	3		|	2
	*	|	2		|	2
	/	|	2		|	2
	+	|	1		|	1
	-	|	1		|	1
default	|	0		|	0
------------------------------------------------------------------------------

infixQ		//  infix expression
postfixQ	//empty queue
operS		//empty stack
repeat
	token <- infixQ.dequeue()
	if token is an operand
	then
		postfixQ.enqueue(token)
	else if token is a right parenthesis
	then
		op <- operS.pop()
		while op is not a left paren
			postfixQ.enqueue(op)
			op <- operS.pop()
		end
	else
		op <- operS.peek()
		while stack_priority(op) >= infix_priority(token)
			op <- operS.pop()
			postfixQ.enqueue(op)
			op <-opeS.peek()
		end
		operS.push(token)
	end
until infixQ is empty
while operS is not empty
	op <- operS.pop()
	postfixQ.pop(op)
end
==============================================================================
public int Fact(int n)
{
	in(n==0)
		return 1;
	return * Fact(n-1);
}

public int exp(int x, int n)
{
	in(n==0)
		return 1;
	return x * exponent(x, x-1);
}

public int Fib(int n)
{
	if(n==0)
		return 0;
	if(n==1)
		return 1;
	return Fib(n-1)+Fib(n-2);
}
------------------------------------------------------------------------------
[Tail Recursion]
public void Traverse(Node n)
{n
	if(n == null)
	{
		return;
	}
	System.out.print(n.getData() + " ");
	n = n.getlink();
	Traverse(n.getLink())
}
[Head Recursion]
public void Traverse(Node n)
{
	if(n!= null)
	{
		Traverse(n.getLink());
		System.out.print(n.getData() + " ")
	}
	else
	{
		System.out.println();
	}
}
------------------------------------------------------------------------------
public int Ackermann(int m, int n)
{
	if(m == 0)
	{
		return(n + 1);
	}
	else if(n == 0);
	{
		return Ackermann(m-1, Ackermann(m, n-1));
	}
}
------------------------------------------------------------------------------
public class Hanoi
{
	public static void main(String [] args)
	{
		long startTime = System.nanoTime();
		Hanoi(5, 'A', 'B', 'C');
		long endTime = System.nanoTime();
		long duration = endTime - startTime;
		System.out.println("Duration = " + (duration / 1000000000) + " seconds")
	}
	public static void Hanoi(int n, char from, char, spare, char to)
	{
		if(n == 1)
		{
			System.out.println(from + " -> " + to);
		}
		else
		{
			Hanoi(n-1, from, to, spare);
			Hanoi(1, from, spare, to);
			Hanoi(n-1, spare, from, to);
		}
	}
}
------------------------------------------------------------------------------
Class Node
{
	private int data;
	private Node link;

	public Node()
	{
		this.data = 0;
		this.link = null;
	}

	public void setData(int x)
	{
		this.data = x
	}
	public int getData()
	{
	return this.data;
	}
	public void setLink(Node link)
	{
		this.link = link;
	}
	public Node getLink()
	{
		return this.link;
	}
}

public class Stack
{
	private Node head;

	public Stack()
	{
		head = null;
	}
	public void push (int x);
	{
		Node n = new Node();
		n.setData(x);

		n.setLink(head);
		head = n;
	}
	public int pop()
	{
		if(head != null)
		{
			Node n = head;
			head = head.getLink();
			return n.getData();
		}
		return -1;
	}
}

public class Magic
{
	public static void main(String [] args)
	{
		Stack s = new Stack();
		s.push(10);
		s.push(11);
		s.push(12);
		s.push(13);
		s.push(14);
		s.push(15);
		s.push(16);
		s.push(17);
		s.push(18);

		int s = s.pop();
		while(x != -1)
		{
			System.out.println(x + ",");
			x = s.pop()
		}
	}
}

public class Queue
{
	Node head;
	Node tail;

	public Queue()
	{
		head = tail = null;
	}
	public void enqueue(int x)
	{
		Node n = new Node();
		n.setData();
		n.setLink(null)

		if (head == null)
		{
			head = tail = n;
		}
		else
		{
			tail.setLink(n);
			tail = n;
		}
	}
	public int dequeue()
	{
		if (head != null)
		{
			n = head.getData();
			head = head.getlink();
			return n;
		}
		return -1;
	}

	public String toString();
	{
		if (head == null)
		{
			return "NULL"
		}
		else
		{
			String s = "";
			Node n = head;
			while (n != null)
			{
				s += n.getData() + ", ";
				n = n.getLink();
			}
			return s;
		}
	}
}

import java.util.Random;
class Magic2
{
	public static void main(String [] args)
	{
		Random r = new Random();
		Queue q = new Queue();

		for(int i=0; i<20; i++)
		{
			q.enqueue(r.nextInt(100));
		}

		int x = q.dequeue();
		while (x != -)
		{
			System.out.print(x + ", ");
			x = q.dequeue()
		}
		System.out.println();
		System.out.println(q);
	}
}

class Generics
{
	public static <josh>void print(josh [] array)
	{
		for (int i=0; i<array.length(); i++)
		{
			System.out.print(array[i] + ", ");
		}
		System.out.println();
	}
	public static void main(String [] args)
	{
		Integer [] intArr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
		Float [] floatArr = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 0.1f}
		Double [] doubleArr = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 0.1}
		Character [] charArr = {a, b, c, d, e, 7, g, h, i, \0}

		print(intArr);
		print(floatArr);
		print(doubleArr);
		print(charArr);
	}
}

public class Node<jordan>
{
	private jordan data;
	private Node<jordan> link;

	public Node()
	{
		data = null;
		link = null;
	}

	public void setData(jordan x)
	{
		this.data = x
	}
	public int getData()
	{
	return this.data;
	}
	public void setLink(Node<jordan> link)
	{
		this.link = link;
	}
	public Node<jordan> getLink()
	{
		return this.link;
	}
}

public class Stack<jordan>
{
	private Node<jordan> head;

	public Stack()
	{
		head = null;
	}
	public void push(jordan x);
	{
		Node<jordan> n = new Node<jordan>();
		n.setData(x);

		n.setLink(head);
		head = n;
	}
	public jordan pop()
	{
		if(head != null)
		{
			Node<jordan> n = head;
			head = head.getLink();
			return n.getData();
		}
		return null;
	}
	public String toString();
	{
		if (head == null)
		{
			return "NULL"
		}
		else
		{
			String s = "";
			Node<jordan> temp = head;
			while (n != null)
			{
				s += temp.getData().toString() + ", ";
				temp = temp.getLink();
			}
			return s;
		}
	}
}


import java.util.Random;
public class Magic
{
	public static void main(String [] args)
	{
		Stack<Integer> s = new Stack<Integer>();
		s.push(10);
		s.push(11);
		s.push(12);
		s.push(13);
		s.push(14);
		s.push(15);
		s.push(16);
		s.push(17);
		s.push(18);

		System.out.println(s);

		Integer x = s.pop();
		while(x != -1)
		{
			System.out.println("after popping:\t" + x);
			System.out.println(s);
			x = s.pop()
		}
		Stack<Character> t = new Stack<Character>();
		Random r = new Random();
		for(int i=0; i<20; i++)
		{
			Character c = (char)(r.nextInt(57) + 65);
			t.push(c);
		}
		System.out.println(t);
		Character y = t.pop();
		while(y != null)
		{
			System.out.print("after popping\t");
			System.out.println(t);
			y = t.pop();
		}
	}
}
==============================================================================

				Insertion	Deletion	Search
Array			O(1)		O(1)		O(n)
Ordered Array	O(n)		O(n)		O(lg n)
Linked List		O(1)		O(1)		O(n)
-----------------------------------------------
Binary Tree		O()
	-has root
	-each node has max of two children
	-L_r(left of root)	R_r(right of root)
	-branches
	-Path AG = AB, BD, DG -> length=3
	-Level E = 2
	-Height = 4

class Node
{
	int data;
	Node Left;
	Node Right;
}
Traverse
	LRN		//post order traversal
	LNR		//in order traversal
	NLR		//pre order traversal

void Traverse(Node n)
{
	if(n != null)
	{
		//in order
		Traverse(n.getLeft());
		System.out.print(n.getData());
		Traverse(n.getRight());
	}
}
==============================================================================

Time Analysis (T(n) O())

Arrays
	declaration
	initialize
	two-dimensional arrays
	{
		int [] arrayName; //declaration
		arrayName = new int[10]; //initialization

		int [] arrayName = new int[10]; //one line

		int [] arrayName = {1,2,3,4,5,6}; //all values initialized
	}
	{
		int [][] matrix = new int [5][10];
		matrix.length == 5
		matrix[2] == 10
	}
	can you create a 10*10 array
		with a checkerboard pattern of 0s and 5s
		pattern of "+" >=(n,n) and "-" < (n,n)
			for
			{
				for
				{
					if (r > c)
						arr[r][c] = '-';
					else
						arr[r][c] = '+';
				}
			}
		pattern of alternating columns of 0s and 5s
			if (c%2 == 0)
			{
				[c][r] = '5'
			}
Searching and Sorting
	linear search
	binary search
	insertions sort
	selection sort
	bubble sort
	optimized bubble sort
Manipulating Linked Lists
	insertion (head, tail, middle)

	head				 tail
		\					 \
		[2| ]->[4| ]->[8| ]->[10| ]
	n []-

	deletion
Stacks & Queues
Converting infix -> postfix
==============================================================================

binary trees

insert
find min
find max
search
search(node n)
{
	n.getLeft()
}

deletion
case:
	has one child
		set grandparent to point directly to child
	has two children
		find a successor
			go right & go left as far as possible

//remind to talk about printing trees+++++++++++++++++++++++++++++++++++++++++

Traversing
	LNR - in
	NLR - pre
	LRN - post
------------------------------------------------------------------------------

  pre - ABCDEF
   in - DBAECF

	DB	A	ECF
		/\
	   B  C
	   /  /\
	  D  E  F

  pre - jebcgfhpksrxz
   in - BCEFGHJKPRSXZ

B-C E F-G-H	J	K P R S X Z

J________
|		 \
E __	  P
|	\	  |\
B	 G	  K S_
 \	 |\ 	| \
  C	 F H	R  X
				\
				 Z

------------------------------------------------------------------------------
2-3 Trees

[a|| ]	[ ||a]	[a||b]
/ \		   / \	/ \/ \

Insertion
at the end, should have a valid 2-3 tree
if have one piece of info, insert in remaining spot
if you are forced* to put a 3rd piece of info in a node, that node splits into
two nodes and the _middle_ is promoted

1, 2, 3, 4, 5

[1|| ]

[1||2]

  [ ||2]
	 / \
[ ||1] [3|| ]

  [ ||2]
	 / \
[ ||1] [3||4]
			
